//object ID contains
1. 4 byte date machin id
2. 5 byte process ID
3. 3 byte random values
... database commands ...
view all database
> show dbs
for create and switch new database
> use newDatabaseName
view current database
> db 

Delete database
db.dropDatabase()

... collections commands...
To switch other database
> use databaseName

To create the new collection
> db.createCollection("comments")

to show the collections
> show Collections

to delete the collection.
> db.collectionName.drop()

... Rows/ fields commands..

To Insert one Row

> db.comments.insertOne({"name": "Aditi kumari", "lang" : "javascript" ,"member": 2})

To Insert many documents

> db.comments.insertMany([{"name": "Aditi kumari", "lang" : "javascript" ,"member": 2},
{"name": "Shamila Devi", "lang" : "javascript" ,"member": 3},
{"name": "Shivam kumar", "lang" : "Java" ,"member": 4}])

To Show the collections 
> db.comments.find().pretty()

To search in mongo db
>db.comments.find({"lang" : "Java"})

Limiting number of rows 
> db.comments.find().limit(2)

To Sort in ascending order
db.comments.find().sort({member : 1}) 

To Sort in desending order
db.comments.find().sort({member : -1})

To remove db
db.content.drop()

To update the documents.

>db.comments.updateOne({name: 'Shubham'},
{$set: {'name': 'Harry',
    'lang': 'JavaScript',
    'member_since': 51
}}, {upsert: true})

Mongodb Rename of field Operator

db.comments.update({name: 'Rohan'},
{$rename:{
    member_since: 'member'
}})

Delete Row (deleteOne, deleteMany, findOneAndDelete)

> db.comments.findOneAndDelete({name: 'Aditi kumari'})

Less than/Greater than/ Less than or Eq/Greater than or Eq

db.comments.find({price: {$lt: 90}})
db.comments.find({price: {$lte: 90}})
db.comments.find({price: {$gt: 90}})
db.comments.find({price: {$gte: 90}})

Remove a Single Field
{ $unset: "<field.nestedfield>" }
or
{ $unset: [ "<field1.nestedfield>", ...] }
db.books.aggregate([ { $unset: "copies" } ])

-- create capped collection
> db.createCollection("test",{capped: true, autoIndexId: true, size: 612334, max: 100})

> db.test.isCapped()

-- convert normal collection to capped 
> db.runCommand({"convertToCapped": "customer", size: 100000})

-- clusture autoIndexId
-- To create the clustered.

db.createCollection(
   "orders",
   { clusteredIndex: { "key": { _id: 1 }, "unique": true, "name": "orders clustered key" } }
)

-- to insert many records in the clustered documents
db.orders.insertMany( [
   { _id: ISODate( "2022-03-18T12:45:20Z" ), "quantity": 50, "totalOrderPrice": 500 },
   { _id: ISODate( "2022-03-18T12:47:00Z" ), "quantity": 5, "totalOrderPrice": 50 },
   { _id: ISODate( "2022-03-18T12:50:00Z" ), "quantity": 1, "totalOrderPrice": 10 }
] )

-- To find the cluster document 

db.orders.find( { _id: { $gt: ISODate( "2022-03-18T12:47:00.000Z" ) } } )

--- cursor ----
[
    {_id: 1, name: 'A', gender: 'M'},
    {_id: 2, name: 'B', gender: 'F'},
    {_id: 3, name: 'C', gender: 'M'},
    {_id: 4, name: 'D', gender: 'F'},
    {_id: 5, name: 'E', gender: 'M'},
    {_id: 6, name: 'F', gender: 'F'},
    {_id: 7, name: 'G', gender: 'M'},
    {_id: 8, name: 'H', gender: 'F'},
    {_id: 9, name: 'I', gender: 'M'},
    {_id: 10, name: 'J', gender: 'F'},
    {_id: 11, name: 'K', gender: 'M'},
    {_id: 12, name: 'L', gender: 'F'},
    {_id: 13, name: 'M', gender: 'M'},
    {_id: 14, name: 'N', gender: 'F'},
    {_id: 15, name: 'P', gender: 'M'},
    {_id: 16, name: 'Q', gender: 'F'},
    {_id: 17, name: 'R', gender: 'M'},
    {_id: 18, name: 'S', gender: 'F'},
    {_id: 19, name: 'T', gender: 'M'},
    {_id: 20, name: 'U', gender: 'M'},
    {_id: 21, name: 'V', gender: 'F'},
    {_id: 22, name: 'W', gender: 'M'},
    {_id: 23, name: 'X', gender: 'F'},
    {_id: 24, name: 'Y', gender: 'M'},
    {_id: 25, name: 'Z', gender: 'F'},
    {_id: 26, name: 'A', gender: 'F'},

]
find methods returns onle some batch of document from all document this is called in cursor in Mongodb

for return more document need pass it 

also toArray() that return all the documents internally

> db.customer.find().toArray()

[
 {
 "maker": "Hyundai",
 "model": "Creta",
 "fuel_type": "Diesel",
 "transmission": "Manual",
 "engine": {
 "type": "Naturally Aspirated",
 "cc": 1493,
 "torque": "250 Nm"
 },
 "features": [
 "Sunroof",
 "Leather Seats",
 "Wireless Charging",
"Ventilated Seats",
"Bluetooth"
 ],
 "sunroof": true,
 "airbags": 6
 },
 {
 "maker": "Maruti Suzuki",
 "model": "Baleno",
 "fuel_type": "Petrol",
 "transmission": "Automatic",
 "engine": {
 "type": "Naturally Aspirated",
 "cc": 1197,
 "torque": "113 Nm"
 },
 "features": [
 "Projector Headlamps",
 "Apple CarPlay",
 "ABS"
 ],
 "sunroof": false,
 "airbags": 2
 },
 {
 "maker": "Mahindra",
 "model": "XUV500",
 "fuel_type": "Diesel",
 "transmission": "Manual",
 "engine": {
 "type": "Turbocharged",
 "cc": 2179,
 "torque": "360 Nm"
 },
 "features": [
 "All-Wheel Drive",
 "Navigation System",
 "Cruise Control"
 ],
 "sunroof": true,
 "airbags": 6
 },
 {
 "maker": "Honda",
 "model": "City",
 "fuel_type": "Petrol",
 "transmission": "Automatic",
 "engine": {
 "type": "Naturally Aspirated",
 "cc": 1498,
 "torque": "145 Nm"
 },
 "features": [
 "Keyless Entry",
 "Auto AC",
 "Multi-angle Rearview Camera"
 ],
 "sunroof": false,
 "airbags": 4
 }
]


>db["car-sample"].find({},{model:1,_id:0})

// update the data form list 
>db.car.updateOne({model:'Nexon'},{$push/pull: {feature}}) 

//update one
>db.car.updateOne({fuel_type: "Diesel"},{$set: {alloys: "yes"}})
//update many
>db.car.updateMany({fuel_type: "Diesel"},{$set: {alloys: "yes"}})

//update Multiple values from Array

db.car.updateOne({model:'Nexon'},
        {$push: {features: {$each: ["Wireless Charging","Voice Control"]}}}
);

// unset from update means remod=ve the field
we can use $unset

delete the records

db.car.deleteOne({fuel_type:"Petrol"})
db.car.deleteMany({fuel_type:"Petrol"})

find more than one engine of cc
db.car.find({"engine.cc":{$in:[1498,2179]}})

Aggregation is a powerful framework for
Complex operations like filtering, grouping, sorting, reshaping, and
summarizing data in a flexible way via pipeline. 


MPrashant

db.collection.aggregate(

       [

         {stage1}, 

         {stage2}...

       ], {option}

     )

db.orders.aggregate([
    //stage 1: filtere pizza order document by pizza size
    {
        $match: { size: 'meduim'}
    },
    // stage2
    {
        $group: { _id: "$name", totalQuantity: { $sum: "$quantity"}}
    }
])     

most comnaly stages aggregate
$match

$group

$project

$sort

$limit

$unwind

$lookup

$addFields

$count

$skip

No of cars of each brands

db.cars.aggregate([

        { $group: 

                       { _id: "$maker", 

                          TotalCars: { $sum: 1 }

                        } 

                   }] )


>db.cars.aggregate([{$match:{maker:"Hyundai","engine.cc":{$gt:1000}}}])
>db.teachers.aggregate([{$match: {gender: "male"}}])

db.users.aggregate([
    {
        $lookup:{
            from : 'orders',
            localField: '_id',
            foreign_field: "user_id",
            ad: "user_order"
        }
    }
])

// it will give the result in Array of array element to solve this we can use


db.users.aggregate([
    {
        $lookup:{
            from : 'orders',
            localField: '_id',
            foreign_field: "user_id",
            ad: "user_orders"
        }
    },
    {$unwind: "user_orders}
])

















